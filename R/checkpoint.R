#' Evaluates an expression or loads a previously checkpointed value
#'
#' Both the change to the environment and the expression's return value is stored.
#' The expression is re-evaluated if the expression or value of the dependent variables change.
#'
#' @param expr any valid R expression
#' @param ckpt.id an identifier used for the checkpointed data
#' @param ... any one or more R objects that are monitored for changes and used to trigger re-evaluation
#' @param force force re-evaluation of the expression
#' @param check.deps whether or not to check the dependent variables in \code{...} for changes
#' @param envir the environment in which \code{expr} is evaluated
#' @param enclos the environment in which \code{expr} is substituted
#' @return the result of running \code{expr} or the checkpointed value
#' @examples
#' checkpointr::checkpoint({x <- 42}, "checkpoint1")
#' @export
checkpoint <-
  function(expr,
           ckpt.id,
           ...,
           force = FALSE,
           check.deps = TRUE,
           envir = parent.frame(),
           enclos = environment()) {
    # Prepare the checkpoint file name
    ckpt_file <- paste0(ckpt.id, ".dat")

    # Set up an environment in which to store the result of the evaluated expression
    tmp_env <- new.env(parent = envir)

    # Substitute the expression
    expr <- substitute(expr, enclos)

    # Calculate the hash used to determine whether a re-evaluation is necessary
    deps_hash <-
      digest::digest(list(deps = ..., expr = deparse(expr)), "sha256")

    if (!force && file.exists(ckpt_file)) {
      # Load the checkpoint if the checkpoint file exists
      message(paste0("Loading checkpoint ", ckpt.id, "."))
      load(ckpt_file, envir = tmp_env)
      ckpt_hash <- tmp_env$.hash

      # Compare the hash to determine whether re-evaluation is necessary
      if (check.deps && (deps_hash != ckpt_hash)) {
        message("Dependent variables have changed!")
        return(checkpoint(
          expr,
          ckpt.id,
          ...,
          force = TRUE,
          envir = envir,
          enclos = enclos
        ))
      }
      retval <- tmp_env$.retval
    } else {
      # Load the data in (re-)evaluation is necessary
      message("Evaluating expression.")
      retval <- eval(expr, envir = tmp_env)
      assign(".retval", retval, tmp_env)
      assign(".hash", deps_hash, tmp_env)
      save(
        list = ls(tmp_env, all.names = TRUE),
        envir = tmp_env,
        file = ckpt_file
      )
    }

    # Populate the parent environment
    copy.env(tmp_env, envir)

    return(retval)
  }

#' Helper function to copy the content of one environment to another
#' @param source_env the environment from which data will be copied
#' @param destination_env the environment to which data will be copied
#' @param all.names whether or not to include hidden variables
copy.env <-
  function(source_env, destination_env, all.names = FALSE) {
    sapply(ls(source_env, all.names = all.names), function(n) {
      assign(n, get(n, source_env), destination_env)
    })
  }
